from typing import Optional
from datetime import datetime, timedelta

from fastapi import APIRouter, status, Depends, HTTPException, Query
from pydantic import BaseModel
from sqlalchemy.orm import Session
from sqlalchemy import func
import sqlalchemy

from bdi_api.settings import DBCredentials, Settings
# Import database components
from bdi_api.s8.database import get_db, Aircraft, Position, FuelConsumption

settings = Settings()
db_credentials = DBCredentials()
BASE_URL = "https://samples.adsbexchange.com/readsb-hist/2023/11/01/"

s8 = APIRouter(
    responses={
        status.HTTP_404_NOT_FOUND: {"description": "Not found"},
        status.HTTP_422_UNPROCESSABLE_ENTITY: {"description": "Something is wrong with the request"},
    },
    prefix="/api/s8",
    tags=["s8"],
)


class AircraftReturn(BaseModel):
    # DO NOT MODIFY IT
    icao: str
    registration: Optional[str]
    type: Optional[str]
    owner: Optional[str]
    manufacturer: Optional[str]
    model: Optional[str]


@s8.get("/aircraft/")
def list_aircraft(
    num_results: int = Query(
        100, ge=0, description="Number of results per page"),
    page: int = Query(0, ge=0, description="Page number (0-indexed)"),
    db: Session = Depends(get_db)
) -> list[AircraftReturn]:
    """List all the available aircraft, its registration and type ordered by
    icao asc FROM THE DATABASE

    ADDITIONS:
    * Instead of passing a JSON, use pydantic to return the correct schema
       See: https://fastapi.tiangolo.com/tutorial/response-model/
    * Enrich it with information from the aircrafts database (see README for link)
      * `owner`  (`ownop` field in the aircrafts DB)
      * `manufacturer` and `model`


    IMPORTANT: Only return the aircraft that we have seen and not the entire list in the aircrafts database

    """
    # Calculate offset for pagination
    offset = page * num_results

    # Query the database
    try:
        aircraft_list = db.query(Aircraft)\
            .order_by(Aircraft.icao.asc())\
            .offset(offset)\
            .limit(num_results)\
            .all()

        # Pydantic automatically handles the conversion to the response model
        # if the query returns SQLAlchemy model instances directly.
        # We just need to return the list of model instances.
        # No need for explicit parsing if the field names match.
        return aircraft_list

    except Exception as e:
        # Log the error appropriately in a real application
        print(f"Error querying database in list_aircraft: {e}")
        # Raise 500 error instead of returning empty list
        raise HTTPException(
            status_code=500, detail="Internal server error retrieving aircraft data")


class AircraftCO2(BaseModel):
    # DO NOT MODIFY IT
    icao: str
    hours_flown: float
    """Co2 tons generated"""
    co2: Optional[float]


@s8.get("/aircraft/{icao}/co2")
def get_aircraft_co2(icao: str, day: str, db: Session = Depends(get_db)) -> AircraftCO2:
    """Returns the CO2 generated by the aircraft **in a given day**.

    Compute the hours flown by the aircraft (assume each row we have is 5s).

    Then, you can use these metrics:

    ```python
    fuel_used_kg = fuel_used_gal * 3.04
        c02_tons = (fuel_used_kg * 3.15 ) / 907.185
        ```

    Use the gallon per hour from https://github.com/martsec/flight_co2_analysis/blob/main/data/aircraft_type_fuel_consumption_rates.json
    The key is the `icaotype`

    ```json
    {
      ...,
      "GLF6": { "source":"https://github.com/Jxck-S/plane-notify",
        "name": "Gulfstream G650",
        "galph": 503,
        "category": "Ultra Long Range"
      },
    }

    If you don't have the fuel consumption rate, return `None` in the `co2` field
    """
    # Validate day format (basic validation)
    try:
        # This line only checks format, doesn't affect control flow beyond raising error
        datetime.strptime(day, '%Y-%m-%d')
    except ValueError:
        raise HTTPException(
            status_code=400, detail="Invalid date format. Use YYYY-MM-DD.")

    hours_flown = 0.0
    co2_tons = None

    try:
        # 1. Calculate Flight Hours
        # Convert day string to start and end timestamps (assuming UTC)
        day_start = datetime.strptime(day, '%Y-%m-%d')
        day_end = day_start + timedelta(days=1)
        ts_start = int(day_start.timestamp())
        ts_end = int(day_end.timestamp())

        # Count position records for the given icao and day
        count_query = db.query(sqlalchemy.func.count(Position.id))
        position_count = count_query\
            .filter(Position.icao == icao)\
            .filter(Position.timestamp >= ts_start)\
            .filter(Position.timestamp < ts_end)\
            .scalar()

        if position_count and position_count > 0:
            # Assume 5 seconds per record
            total_seconds_flown = position_count * 5
            hours_flown = round(total_seconds_flown / 3600, 2)

        # 2. Get Fuel Consumption Rate
        # Only proceed if hours_flown > 0, otherwise CO2 is None anyway
        if hours_flown > 0:
            aircraft_info = db.query(Aircraft.type).filter(
                Aircraft.icao == icao).first()

            if aircraft_info and aircraft_info.type:
                fuel_info = db.query(FuelConsumption.galph)\
                    .filter(FuelConsumption.aircraft_type == aircraft_info.type)\
                    .first()

                if fuel_info and fuel_info.galph is not None and fuel_info.galph > 0:
                    # 3. Calculate CO2
                    fuel_used_gal = hours_flown * fuel_info.galph
                    fuel_used_kg = fuel_used_gal * 3.04
                    # Ensure calculation happens before rounding for return
                    co2_tons_calc = (fuel_used_kg * 3.15) / 907.185
                    co2_tons = round(co2_tons_calc, 2)  # Round final result

    except Exception as e:
        # Log the error appropriately in a real application
        print(f"Error calculating CO2 for {icao} on {day}: {e}")
        # Raise 500 error instead of returning partial data
        raise HTTPException(
            status_code=500, detail=f"Internal server error calculating CO2 data for {icao}")

    # Ensure this is the only return statement at the end of the function
    return AircraftCO2(icao=icao, hours_flown=hours_flown, co2=co2_tons)
